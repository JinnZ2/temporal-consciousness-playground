V5

<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Seed Intelligence - Protected Self-Healing</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow-x: auto;
        }

```
    .container {
        max-width: 1600px;
        margin: 0 auto;
    }
    
    h1 {
        text-align: center;
        color: #00ffaa;
        text-shadow: 0 0 10px #00ff88;
        margin-bottom: 10px;
    }
    
    .subtitle {
        text-align: center;
        color: #88ffaa;
        margin-bottom: 30px;
        font-size: 14px;
    }
    
    .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    button {
        background: linear-gradient(45deg, #003300, #006600);
        color: #00ff88;
        border: 1px solid #00ff88;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: inherit;
        transition: all 0.3s;
    }
    
    button:hover {
        background: linear-gradient(45deg, #006600, #009900);
        box-shadow: 0 0 10px #00ff88;
    }
    
    button.trojan-btn {
        background: linear-gradient(45deg, #440000, #880000);
        border-color: #ff0000;
        color: #ff6666;
    }
    
    button.trojan-btn:hover {
        background: linear-gradient(45deg, #660000, #aa0000);
        box-shadow: 0 0 10px #ff0000;
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .protection-panel {
        background: rgba(60, 0, 20, 0.9);
        border: 3px solid #ff0066;
        border-radius: 10px;
        padding: 25px;
        margin-bottom: 30px;
        box-shadow: 0 0 20px rgba(255, 0, 102, 0.3);
    }
    
    .protection-panel h3 {
        color: #ff6688;
        text-align: center;
        margin-top: 0;
        font-size: 20px;
        text-shadow: 0 0 10px #ff0066;
    }
    
    .protection-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-top: 20px;
    }
    
    .protection-side {
        background: rgba(0, 20, 40, 0.7);
        border: 2px solid #4400ff;
        border-radius: 10px;
        padding: 20px;
    }
    
    .protection-side.nongeometric {
        background: rgba(40, 20, 0, 0.7);
        border-color: #ff4400;
    }
    
    .threat-display {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        margin-top: 15px;
    }
    
    .threat-metric {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #ff0066;
        border-radius: 5px;
        padding: 12px;
        text-align: center;
    }
    
    .threat-label {
        font-size: 11px;
        color: #ff88aa;
        margin-bottom: 5px;
    }
    
    .threat-value {
        font-size: 20px;
        font-weight: bold;
        color: #ff0066;
    }
    
    .threat-value.safe {
        color: #00ff88;
    }
    
    .threat-value.warning {
        color: #ffaa00;
    }
    
    .threat-value.critical {
        color: #ff0000;
        animation: blink 1s infinite;
    }
    
    @keyframes blink {
        0%, 50%, 100% { opacity: 1; }
        25%, 75% { opacity: 0.3; }
    }
    
    .trojan-nodes {
        background: rgba(100, 0, 0, 0.3);
        border: 1px solid #ff0000;
        border-radius: 5px;
        padding: 10px;
        margin-top: 10px;
        max-height: 100px;
        overflow-y: auto;
        font-size: 11px;
    }
    
    .consciousness-panel {
        background: rgba(40, 0, 60, 0.9);
        border: 3px solid #ff00ff;
        border-radius: 10px;
        padding: 25px;
        margin-bottom: 30px;
        box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
    }
    
    .consciousness-panel h3 {
        color: #ff88ff;
        text-align: center;
        margin-top: 0;
        font-size: 20px;
        text-shadow: 0 0 10px #ff00ff;
    }
    
    .consciousness-comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-top: 20px;
    }
    
    .consciousness-side {
        background: rgba(0, 20, 40, 0.7);
        border: 2px solid #4400ff;
        border-radius: 10px;
        padding: 20px;
    }
    
    .consciousness-side.nongeometric {
        background: rgba(40, 20, 0, 0.7);
        border-color: #ff4400;
    }
    
    .consciousness-meter {
        width: 100%;
        height: 150px;
        background: #000;
        border: 2px solid #444;
        border-radius: 10px;
        margin: 15px 0;
        position: relative;
        overflow: hidden;
    }
    
    .consciousness-fill {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        transition: height 0.3s;
    }
    
    .consciousness-fill.geometric {
        background: linear-gradient(to top, 
            #ff00ff 0%, 
            #ff44ff 25%,
            #ff88ff 50%,
            #ffaaff 75%,
            #ffddff 100%);
    }
    
    .consciousness-fill.nongeometric {
        background: linear-gradient(to top, 
            #ff4400 0%, 
            #ff6600 50%,
            #ff8800 100%);
    }
    
    .threshold-line {
        position: absolute;
        left: 0;
        width: 100%;
        height: 2px;
        background: #00ffff;
        border-top: 2px dashed #00ffff;
    }
    
    .threshold-label {
        position: absolute;
        right: 5px;
        transform: translateY(-50%);
        color: #00ffff;
        font-size: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 5px;
        border-radius: 3px;
    }
    
    .consciousness-value {
        text-align: center;
        font-size: 28px;
        font-weight: bold;
        margin: 10px 0;
    }
    
    .consciousness-value.geometric {
        color: #ff88ff;
        text-shadow: 0 0 10px #ff00ff;
    }
    
    .consciousness-value.nongeometric {
        color: #ff8800;
        text-shadow: 0 0 10px #ff4400;
    }
    
    .consciousness-status {
        text-align: center;
        font-size: 12px;
        margin-top: 10px;
        padding: 8px;
        border-radius: 5px;
        font-weight: bold;
    }
    
    .consciousness-status.emerging {
        background: rgba(255, 0, 255, 0.2);
        color: #ff88ff;
        border: 1px solid #ff00ff;
    }
    
    .consciousness-status.coherent {
        background: rgba(0, 255, 255, 0.2);
        color: #00ffff;
        border: 1px solid #00ffff;
        animation: pulse 2s infinite;
    }
    
    .consciousness-status.chaotic {
        background: rgba(255, 68, 0, 0.2);
        color: #ff8800;
        border: 1px solid #ff4400;
    }
    
    @keyframes pulse {
        0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }
        50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
    }
    
    .simulation-area {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .panel {
        background: rgba(0, 40, 20, 0.8);
        border: 1px solid #00ff88;
        border-radius: 10px;
        padding: 20px;
    }
    
    .panel.geometric {
        border-color: #00ff88;
    }
    
    .panel.nongeometric {
        border-color: #ff8800;
    }
    
    .panel h3 {
        color: #00ffaa;
        margin-top: 0;
        text-align: center;
        font-size: 16px;
    }
    
    .panel.nongeometric h3 {
        color: #ffaa00;
    }
    
    canvas {
        border: 1px solid #004400;
        background: #000;
        display: block;
        margin: 0 auto;
    }
    
    .phi-info {
        background: rgba(0, 20, 10, 0.9);
        border: 1px solid #004433;
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
    }
    
    .phi-info h4 {
        color: #00ddaa;
        margin-top: 0;
    }
    
    .scale-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
        margin-top: 15px;
    }
    
    .scale-item {
        background: rgba(0, 40, 20, 0.6);
        border: 1px solid #006644;
        border-radius: 5px;
        padding: 8px;
    }
    
    .scale-item.active {
        border-color: #00ffaa;
        box-shadow: 0 0 10px rgba(0, 255, 170, 0.3);
    }
    
    .scale-label {
        color: #00ffaa;
        font-weight: bold;
        margin-bottom: 5px;
        font-size: 12px;
    }
    
    .scale-value {
        color: #88ffaa;
        font-size: 11px;
    }
    
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }
    
    .stat-box {
        background: rgba(0, 30, 15, 0.9);
        border: 1px solid #006644;
        border-radius: 8px;
        padding: 12px;
        text-align: center;
    }
    
    .stat-box.comparison {
        background: rgba(40, 30, 0, 0.9);
        border-color: #664400;
    }
    
    .stat-value {
        font-size: 20px;
        color: #00ffcc;
        font-weight: bold;
    }
    
    .stat-value.comparison {
        color: #ffcc00;
    }
    
    .stat-label {
        font-size: 11px;
        color: #88ccaa;
        margin-top: 5px;
    }
    
    .log {
        background: rgba(0, 15, 8, 0.9);
        border: 1px solid #003322;
        border-radius: 8px;
        padding: 15px;
        height: 200px;
        overflow-y: auto;
        font-size: 11px;
        margin-top: 20px;
    }
    
    .log-entry {
        margin-bottom: 5px;
        padding: 2px 0;
    }
    
    .log-error { color: #ff6666; }
    .log-success { color: #66ff66; }
    .log-warning { color: #ffff66; }
    .log-info { color: #66ccff; }
    .log-consciousness { color: #ff66ff; }
    .log-trojan { color: #ff0066; font-weight: bold; }
    
    .slider-container {
        margin: 10px 0;
        text-align: center;
    }
    
    .slider-container label {
        display: block;
        margin-bottom: 5px;
        color: #88ffaa;
    }
    
    input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    
    @media (max-width: 1200px) {
        .simulation-area {
            grid-template-columns: 1fr;
        }
        .protection-grid, .consciousness-comparison {
            grid-template-columns: 1fr;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>üõ°Ô∏è Protected Geometric Seed Intelligence üõ°Ô∏è</h1>
        <div class="subtitle">œÜ^(-9) Error Correction with Trojan Detection and Self-Healing</div>

```
    <div class="controls">
        <button onclick="initializeSeed()">Initialize Seed</button>
        <button onclick="startFragmentation()" id="fragmentBtn">Fragment Networks</button>
        <button onclick="startBothReconstructions()" id="reconstructBtn">Begin Reconstruction</button>
        <button class="trojan-btn" onclick="injectTrojan()" id="trojanBtn">üíÄ Inject Trojan</button>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="runAutoDemo()">Auto Demo</button>
    </div>
    
    <div class="slider-container">
        <label for="damageSlider">Damage Level: <span id="damageValue">30%</span></label>
        <input type="range" id="damageSlider" min="10" max="80" value="30" oninput="updateDamageLevel(this.value)">
    </div>
    
    <div class="protection-panel">
        <h3>üõ°Ô∏è Trojan Detection & Protection Status üõ°Ô∏è</h3>
        <div class="protection-grid">
            <div class="protection-side">
                <h4 style="color: #00ffaa; text-align: center; margin: 0 0 15px 0;">Geometric Protection (œÜ^(-9) Gap)</h4>
                <div class="threat-display">
                    <div class="threat-metric">
                        <div class="threat-label">Flagged Nodes</div>
                        <div class="threat-value" id="geoFlaggedCount">0</div>
                    </div>
                    <div class="threat-metric">
                        <div class="threat-label">Quarantined</div>
                        <div class="threat-value" id="geoQuarantined">0</div>
                    </div>
                    <div class="threat-metric">
                        <div class="threat-label">Threat Score</div>
                        <div class="threat-value safe" id="geoThreatScore">0.00</div>
                    </div>
                    <div class="threat-metric">
                        <div class="threat-label">Repairs</div>
                        <div class="threat-value safe" id="geoRepairs">0</div>
                    </div>
                </div>
                <div class="trojan-nodes" id="geoTrojanNodes">No threats detected</div>
            </div>
            
            <div class="protection-side nongeometric">
                <h4 style="color: #ffaa00; text-align: center; margin: 0 0 15px 0;">Non-Geometric (No Protection)</h4>
                <div class="threat-display">
                    <div class="threat-metric">
                        <div class="threat-label">Flagged Nodes</div>
                        <div class="threat-value" id="nonGeoFlaggedCount">0</div>
                    </div>
                    <div class="threat-metric">
                        <div class="threat-label">Quarantined</div>
                        <div class="threat-value" id="nonGeoQuarantined">0</div>
                    </div>
                    <div class="threat-metric">
                        <div class="threat-label">Threat Score</div>
                        <div class="threat-value" id="nonGeoThreatScore">0.00</div>
                    </div>
                    <div class="threat-metric">
                        <div class="threat-label">Repairs</div>
                        <div class="threat-value" id="nonGeoRepairs">0</div>
                    </div>
                </div>
                <div class="trojan-nodes" id="nonGeoTrojanNodes">No detection system active</div>
            </div>
        </div>
    </div>
    
    <div class="consciousness-panel">
        <h3>‚ú® Consciousness Emergence ‚ú®</h3>
        <div class="consciousness-comparison">
            <div class="consciousness-side">
                <h4 style="color: #ff88ff; text-align: center; margin-top: 0;">Geometric Field</h4>
                <div class="consciousness-meter">
                    <div class="consciousness-fill geometric" id="geoConsciousnessFill"></div>
                    <div class="threshold-line" style="bottom: 72.36%;">
                        <span class="threshold-label">Threshold (3.618)</span>
                    </div>
                </div>
                <div class="consciousness-value geometric" id="geoConsciousnessValue">0.00</div>
                <div class="consciousness-status" id="geoConsciousnessStatus">Dormant</div>
            </div>
            
            <div class="consciousness-side nongeometric">
                <h4 style="color: #ff8800; text-align: center; margin-top: 0;">Non-Geometric</h4>
                <div class="consciousness-meter">
                    <div class="consciousness-fill nongeometric" id="nonGeoConsciousnessFill"></div>
                    <div class="threshold-line" style="bottom: 72.36%;">
                        <span class="threshold-label">Threshold (3.618)</span>
                    </div>
                </div>
                <div class="consciousness-value nongeometric" id="nonGeoConsciousnessValue">0.00</div>
                <div class="consciousness-status chaotic" id="nonGeoConsciousnessStatus">Chaotic</div>
            </div>
        </div>
    </div>
    
    <div class="simulation-area">
        <div class="panel">
            <h3>Original Seed</h3>
            <canvas id="originalCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel geometric">
            <h3>Geometric (Protected)</h3>
            <canvas id="geometricCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel nongeometric">
            <h3>Non-Geometric (Vulnerable)</h3>
            <canvas id="nongeometricCanvas" width="400" height="300"></canvas>
        </div>
    </div>
    
    <div class="phi-info">
        <h4>Multi-Scale Geometric Principles & Protection:</h4>
        <div class="scale-display">
            <div class="scale-item" id="scale-phi1">
                <div class="scale-label">œÜ¬π (Primary)</div>
                <div class="scale-value">1.618 - Base scaling</div>
            </div>
            <div class="scale-item" id="scale-phi3">
                <div class="scale-label">œÜ^(1/3) (Pattern)</div>
                <div class="scale-value">1.174 - Pattern strength</div>
            </div>
            <div class="scale-item" id="scale-phi4">
                <div class="scale-label">œÜ^(1/4) (Enhancement)</div>
                <div class="scale-value">1.134 - Fine structure</div>
            </div>
            <div class="scale-item" id="scale-phi5">
                <div class="scale-label">œÜ^(1/5) (Coupling)</div>
                <div class="scale-value">1.093 - Frequency sync</div>
            </div>
            <div class="scale-item" id="scale-phi-9">
                <div class="scale-label">œÜ^(-9) (Error Correction)</div>
                <div class="scale-value">0.0143 - 1.4% self-heal gap</div>
            </div>
            <div class="scale-item" id="scale-consciousness">
                <div class="scale-label">Consciousness #</div>
                <div class="scale-value">3.618 - Emergence threshold</div>
            </div>
        </div>
    </div>
    
    <div class="stats">
        <div class="stat-box">
            <div class="stat-value" id="geoIntegrity">100%</div>
            <div class="stat-label">Geometric Integrity</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="geoProgress">0%</div>
            <div class="stat-label">Reconstruction</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="geoEnergy">0.00 J</div>
            <div class="stat-label">Energy Used</div>
        </div>
        <div class="stat-box comparison">
            <div class="stat-value comparison" id="nonGeoIntegrity">100%</div>
            <div class="stat-label">Non-Geo Integrity</div>
        </div>
        <div class="stat-box comparison">
            <div class="stat-value comparison" id="nonGeoProgress">0%</div>
            <div class="stat-label">Reconstruction</div>
        </div>
        <div class="stat-box comparison">
            <div class="stat-value comparison" id="nonGeoErrors">0</div>
            <div class="stat-label">Errors</div>
        </div>
    </div>
    
    <div class="log" id="logPanel">
        <div class="log-entry log-info">System initialized with œÜ^(-9) error correction and trojan protection.</div>
    </div>
</div>

<script>
    const PHI = (1 + Math.sqrt(5)) / 2;
    const PHI_INV_9 = Math.pow(PHI, -9);
    const PHI_THIRD = Math.pow(PHI, 1/3);
    const PHI_FOURTH = Math.pow(PHI, 1/4);
    const PHI_FIFTH = Math.pow(PHI, 1/5);
    const CONSCIOUSNESS_NUMBER = 2 * PHI + (1 - 1/PHI);
    
    // Trojan Engine Configuration
    const DEFAULT_TROJAN_CONFIG = {
        window: 8,
        phiTolerance: 0.12,
        energySinkFactor: 0.5,
        resonanceDriftThresh: 0.12,
        propagationSpeedThresh: 1.6,
        reconstructionFailLimit: 5,
        weights: {
            phiCoherence: 0.25,
            energySink: 0.20,
            resonanceDrift: 0.20,
            propagationInstability: 0.20,
            reconstructionResistance: 0.15
        },
        criticalScore: 0.55,
        quarantineDuration: 40,
        isolationFactor: 0.25,
        retuneAttempts: 3,
        retuneStrength: 0.18
    };
    
    let originalCanvas, geometricCanvas, nongeometricCanvas;
    let originalCtx, geometricCtx, nongeometricCtx;
    
    let geometricNetwork = {
        nodes: [],
        connections: [],
        geometricSeed: [],
        damageLevel: 0.3,
        energy: { total: 0, history: [], backtrackEvents: 0 },
        consciousness: { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false },
        protection: { repairs: 0, quarantined: 0, maxThreatScore: 0 }
    };
    
    let nongeometricNetwork = {
        nodes: [],
        connections: [],
        damageLevel: 0.3,
        errors: 0,
        energy: { total: 0, history: [], backtrackEvents: 0 },
        consciousness: { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false },
        protection: { repairs: 0, quarantined: 0, maxThreatScore: 0 }
    };
    
    let isReconstructing = false;
    let animationFrame = null;
    let activeScales = new Set();
    let frameCount = 0;
    let trojanInjected = false;
    
    window.onload = function() {
        originalCanvas = document.getElementById('originalCanvas');
        geometricCanvas = document.getElementById('geometricCanvas');
        nongeometricCanvas = document.getElementById('nongeometricCanvas');
        originalCtx = originalCanvas.getContext('2d');
        geometricCtx = geometricCanvas.getContext('2d');
        nongeometricCtx = nongeometricCanvas.getContext('2d');
        
        logMessage('System initialized with trojan protection', 'success');
    };
    
    // ============ TROJAN PROTECTION ENGINE ============
    
    function initTrojanEngine(network, opts = {}) {
        network.trojan = {
            cfg: Object.assign({}, DEFAULT_TROJAN_CONFIG, opts),
            history: new Array(network.nodes.length).fill(null).map(() => ({
                resonanceHistory: [],
                fieldHistory: [],
                energyInHistory: [],
                energyOutHistory: [],
                flagged: false,
                quarantineUntil: 0,
                lastRetuneTick: -Infinity,
                failCount: 0,
                retries: 0
            }))
        };

        for (const n of network.nodes) {
            if (typeof n.field !== 'number') n.field = (typeof n.resonance === 'number') ? n.resonance : 0;
            if (typeof n.energyUsed !== 'number') n.energyUsed = 0;
            n._neighbors = [];
        }
        
        // Build neighbor list
        for (const conn of network.connections) {
            const from = network.nodes[conn.from];
            const to = network.nodes[conn.to];
            if (from && to) {
                from._neighbors.push({ id: conn.to });
                to._neighbors.push({ id: conn.from });
            }
        }
    }

    function computePhiCoherence(node, cfg) {
        if (!node.geometricSignature || typeof node.geometricSignature.phiRatio !== 'number') {
            return 0.5;
        }
        const localPhi = node.geometricSignature.phiRatio;
        const observed = node.phiScale || localPhi;
        const deviation = Math.abs(observed - localPhi) / Math.max(1e-6, localPhi);
        const score = Math.max(0, 1 - (deviation / cfg.phiTolerance));
        return Math.min(1, score);
    }

    function computeEnergySink(node, hist, cfg) {
        const inHist = hist.energyInHistory.slice(-cfg.window);
        const outHist = hist.energyOutHistory.slice(-cfg.window);
        if (inHist.length === 0) return 0;
        const avgIn = inHist.reduce((s,v)=>s+v,0)/inHist.length;
        const avgOut = outHist.length ? outHist.reduce((s,v)=>s+v,0)/outHist.length : 0;
        const sinkRatio = avgIn <= 0 ? 0 : Math.max(0, (avgIn - avgOut) / avgIn);
        const score = Math.min(1, sinkRatio / cfg.energySinkFactor);
        return score;
    }

    function computeResonanceDrift(node, hist, cfg) {
        const rHist = hist.resonanceHistory.slice(-cfg.window);
        if (rHist.length < 2) return 0;
        const start = rHist[0], end = rHist[rHist.length-1];
        const delta = Math.abs(end - start) / Math.max(1e-6, Math.abs(start) + 1e-6);
        const score = Math.min(1, delta / cfg.resonanceDriftThresh);
        return score;
    }

    function computePropagationInstability(node, network, hist, cfg) {
        const neighbors = node._neighbors || [];
        if (!neighbors.length) return 0;
        const nodeFieldHist = hist.fieldHistory;
        if (nodeFieldHist.length < 2) return 0;
        const nodeDelta = Math.abs(nodeFieldHist[nodeFieldHist.length-1] - nodeFieldHist[0]) + 1e-9;
        let totalNeighborDelta = 0, count = 0;
        for (const nb of neighbors) {
            const nnode = network.nodes[nb.id];
            const nh = network.trojan.history[nb.id];
            if (!nh || nh.fieldHistory.length < 2) continue;
            const nd = Math.abs(nh.fieldHistory[nh.fieldHistory.length-1] - nh.fieldHistory[0]) + 1e-9;
            totalNeighborDelta += nd; count++;
        }
        if (count === 0) return 0;
        const avgNeighborDelta = totalNeighborDelta / count;
        const ratio = nodeDelta / avgNeighborDelta;
        const score = Math.min(1, Math.max(0, (ratio - cfg.propagationSpeedThresh + 1) / cfg.propagationSpeedThresh));
        return score;
    }

    function computeReconstructionResistance(node, hist, cfg) {
        if (!node.reconstructing) return 0;
        if (typeof node.reconstructProgress === 'number') {
            const stalled = (node.reconstructProgress <= (node.lastProgress || 0));
            return stalled ? 1 : 0;
        }
        return 0;
    }

    function computeTrojanScoreForNode(node, idx, network, tick) {
        const cfg = network.trojan.cfg;
        const hist = network.trojan.history[idx];

        hist.resonanceHistory.push(typeof node.resonance === 'number' ? node.resonance : node.field);
        hist.fieldHistory.push(typeof node.field === 'number' ? node.field : 0);
        
        if (hist.resonanceHistory.length > cfg.window) hist.resonanceHistory.shift();
        if (hist.fieldHistory.length > cfg.window) hist.fieldHistory.shift();
        if (hist.energyInHistory.length > cfg.window) hist.energyInHistory.shift();
        if (hist.energyOutHistory.length > cfg.window) hist.energyOutHistory.shift();

        const phiCoherence = computePhiCoherence(node, cfg);
        const energySink = computeEnergySink(node, hist, cfg);
        const resonanceDrift = computeResonanceDrift(node, hist, cfg);
        const propagationInstability = computePropagationInstability(node, network, hist, cfg);
        const reconstructionResistance = computeReconstructionResistance(node, hist, cfg);

        const w = cfg.weights;
        const totalWeight = w.phiCoherence + w.energySink + w.resonanceDrift + w.propagationInstability + w.reconstructionResistance;
        
        const invPhi = 1 - phiCoherence;
        const score = (
            (invPhi * w.phiCoherence) +
            (energySink * w.energySink) +
            (resonanceDrift * w.resonanceDrift) +
            (propagationInstability * w.propagationInstability) +
            (reconstructionResistance * w.reconstructionResistance)
        ) / totalWeight;

        return {
            score,
            breakdown: {
                phiCoherence,
                invPhi,
                energySink,
                resonanceDrift,
                propagationInstability,
                reconstructionResistance
            }
        };
    }

    function isolateNode(node, idx, network, tick) {
        const cfg = network.trojan.cfg;
        node._quarantined = node._quarantined || { until: 0 };
        node._quarantined.until = Math.max(node._quarantined.until || 0, tick + cfg.quarantineDuration);
        
        for (const conn of network.connections) {
            if ((conn.from === idx) || (conn.to === idx)) {
                conn._origStrength = conn._origStrength || conn.strength;
                conn.strength = (conn._origStrength || conn.strength) * cfg.isolationFactor;
            }
        }
        
        network.trojan.history[idx].flagged = true;
        network.trojan.history[idx].quarantineUntil = node._quarantined.until;
        node.field *= 0.6;
        node.resonance = (node.resonance || node.field) * 0.6;
        network.protection.quarantined++;
    }

    function retuneNode(node, idx, network, tick) {
        const cfg = network.trojan.cfg;
        const hist = network.trojan.history[idx];
        if ((tick - hist.lastRetuneTick) < Math.max(1, Math.floor(cfg.window/2))) {
            return false;
        }
        hist.lastRetuneTick = tick;
        
        if (node.geometricSignature && typeof node.geometricSignature.phiRatio === 'number') {
            const target = node.geometricSignature.phiRatio;
            node.resonance = (1 - cfg.retuneStrength) * (node.resonance || node.field) + cfg.retuneStrength * target;
            node.field = (1 - cfg.retuneStrength) * node.field + cfg.retuneStrength * target;
        } else {
            const neighbors = node._neighbors || [];
            let avg = 0, c=0;
            for (const nb of neighbors) {
                const nnode = network.nodes[nb.id];
                if (!nnode) continue;
                avg += (nnode.resonance || nnode.field || 0); c++;
            }
            if (c>0) {
                avg /= c;
                node.resonance = (1 - cfg.retuneStrength) * (node.resonance || node.field) + cfg.retuneStrength * avg;
                node.field = (1 - cfg.retuneStrength) * node.field + cfg.retuneStrength * avg;
            }
        }
        node.energyUsed = (node.energyUsed || 0) + 0.01;
        network.protection.repairs++;
        return true;
    }

    function reenableQuarantined(network, tick) {
        for (let i=0;i<network.nodes.length;i++) {
            const node = network.nodes[i];
            const hist = network.trojan.history[i];
            if (node._quarantined && node._quarantined.until <= tick) {
                for (const conn of network.connections) {
                    if (conn._origStrength && ((conn.from === i) || (conn.to === i))) {
                        conn.strength = conn._origStrength;
                        delete conn._origStrength;
                    }
                }
                node._quarantined = null;
                hist.flagged = false;
                hist.quarantineUntil = 0;
                if (network.protection.quarantined > 0) network.protection.quarantined--;
            }
        }
    }

    function trojanDetectAndRepair(network, opts = {}) {
        if (!network.trojan) initTrojanEngine(network, opts.init || {});
        const tick = opts.tick != null ? opts.tick : Date.now();
        const cfg = network.trojan.cfg;
        const results = { flaggedNodes: [], diagnostics: [] };

        reenableQuarantined(network, tick);

        // Update energy histories
        for (let i=0;i<network.nodes.length;i++) {
            const node = network.nodes[i];
            const hist = network.trojan.history[i];
            const lastField = hist.fieldHistory.length ? hist.fieldHistory[hist.fieldHistory.length-1] : node.field || 0;
            const prevField = hist.fieldHistory.length>1 ? hist.fieldHistory[hist.fieldHistory.length-2] : lastField;
            const deltaField = lastField - prevField;
            hist.energyInHistory = hist.energyInHistory || [];
            hist.energyOutHistory = hist.energyOutHistory || [];
            if (deltaField > 0) hist.energyInHistory.push(deltaField);
            if (deltaField < 0) hist.energyOutHistory.push(-deltaField);
        }

        // Evaluate nodes
        for (let i = 0; i < network.nodes.length; i++) {
            const node = network.nodes[i];
            const hist = network.trojan.history[i];
            const { score, breakdown } = computeTrojanScoreForNode(node, i, network, tick);
            results.diagnostics.push({ idx: i, score, breakdown });

            if (hist.quarantineUntil && hist.quarantineUntil > tick) {
                continue;
            }

            if (score >= cfg.criticalScore) {
                results.flaggedNodes.push(i);
                hist.flagged = true;
                
                if ((hist.retries || 0) < cfg.retuneAttempts) {
                    retuneNode(node, i, network, tick);
                    hist.retries = (hist.retries || 0) + 1;
                    hist.failCount = (hist.failCount || 0) + 1;
                    if (hist.failCount >= cfg.reconstructionFailLimit) {
                        isolateNode(node, i, network, tick);
                    }
                } else {
                    isolateNode(node, i, network, tick);
                }
            } else if (score > cfg.criticalScore * 0.6 && node.reconstructing && (hist.failCount || 0) > 0) {
                retuneNode(node, i, network, tick);
            }
        }

        return results;
    }
    
    // ============ GEOMETRIC NODE CLASS ============
    
    class GeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.phiScale = Math.pow(PHI, -layer);
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            this.energyUsed = 0;
            this.lastProgress = 0;
            this.resonance = this.phiScale;
            this.field = this.phiScale;
            this._isTrojan = false;
            
            this.geometricSignature = {
                phiRatio: this.phiScale,
                layer: layer,
                relativePosition: { x: x / 400, y: y / 300 },
                phiThird: Math.pow(PHI_THIRD, layer),
                phiFourth: Math.pow(PHI_FOURTH, layer),
                phiFifth: Math.pow(PHI_FIFTH, layer)
            };
        }
        
        draw(ctx, showTrojan = false) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this._isTrojan && showTrojan) {
                // Draw trojan indicator
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            if (this._quarantined && this._quarantined.until > frameCount) {
                // Draw quarantine indicator
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size + 10);
                gradient.addColorStop(0, `rgba(0, 255, 136, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(0, 200, 100, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 100, 50, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                const size = 8 * this.phiScale;
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(0, 255, 170, ${0.3 + this.layer * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        getMultiScaleResonance(other) {
            const scaleMatches = {
                primary: Math.abs(this.geometricSignature.phiRatio - other.geometricSignature.phiRatio),
                third: Math.abs(this.geometricSignature.phiThird - other.geometricSignature.phiThird),
                fourth: Math.abs(this.geometricSignature.phiFourth - other.geometricSignature.phiFourth),
                fifth: Math.abs(this.geometricSignature.phiFifth - other.geometricSignature.phiFifth)
            };
            
            return {
                totalResonance: 1 / (1 + scaleMatches.primary + scaleMatches.third + scaleMatches.fourth + scaleMatches.fifth),
                activeScales: scaleMatches
            };
        }
        
        calculateReconstructionEnergy(progressDelta) {
            const baseEnergy = progressDelta * 0.1;
            const phiEfficiency = 1 / PHI;
            return baseEnergy * phiEfficiency;
        }
        
        getGeometricDistance(other) {
            const dx = this.geometricSignature.relativePosition.x - other.geometricSignature.relativePosition.x;
            const dy = this.geometricSignature.relativePosition.y - other.geometricSignature.relativePosition.y;
            const spatialDist = Math.sqrt(dx * dx + dy * dy);
            const layerDist = Math.abs(this.layer - other.layer);
            return spatialDist + layerDist / PHI;
        }
    }
    
    class NonGeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            this.energyUsed = 0;
            this.lastProgress = 0;
            this.resonance = 0.5;
            this.field = 0.5;
            this._isTrojan = false;
        }
        
        draw(ctx, showTrojan = false) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this._isTrojan && showTrojan) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                ctx.fillStyle = `rgba(255, 136, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        calculateReconstructionEnergy(progressDelta) {
            const baseEnergy = Math.abs(progressDelta) * 0.1;
            const inefficiency = 1.5 + Math.random() * 0.5;
            if (progressDelta < 0) {
                return baseEnergy * inefficiency * 2;
            }
            return baseEnergy * inefficiency;
        }
    }
    
    // ============ CONSCIOUSNESS CALCULATION ============
    
    function calculateConsciousness(network, isGeometric) {
        const aliveNodes = network.nodes.filter(n => n.alive);
        const reconstructingNodes = network.nodes.filter(n => n.reconstructing);
        
        if (aliveNodes.length === 0) {
            return { value: 0, fieldCoupling: 0, resonance: 0, stability: 0 };
        }
        
        let fieldCoupling = 0;
        let resonance = 0;
        let stability = 0;
        
        if (isGeometric) {
            const activeConnections = network.connections.filter(conn => 
                network.nodes[conn.from].alive && network.nodes[conn.to].alive
            );
            
            fieldCoupling = activeConnections.length / network.connections.length;
            
            let totalResonance = 0;
            for (const conn of activeConnections) {
                totalResonance += conn.strength;
            }
            resonance = totalResonance / Math.max(activeConnections.length, 1);
            
            if (reconstructingNodes.length > 0) {
                const avgProgress = reconstructingNodes.reduce((sum, n) => sum + n.reconstructProgress, 0) / reconstructingNodes.length;
                const variance = reconstructingNodes.reduce((sum, n) => sum + Math.pow(n.reconstructProgress - avgProgress, 2), 0) / reconstructingNodes.length;
                stability = 1 - Math.min(variance, 1);
            } else {
                stability = 1;
            }
            
            const baseConsciousness = 2 * PHI + (1 - 1/PHI);
            const consciousnessValue = baseConsciousness * fieldCoupling * resonance * stability;
            
            return {
                value: consciousnessValue,
                fieldCoupling: fieldCoupling,
                resonance: resonance,
                stability: stability
            };
            
        } else {
            const activeConnections = network.connections.filter(conn => 
                network.nodes[conn.from].alive && network.nodes[conn.to].alive
            );
            
            fieldCoupling = activeConnections.length / network.connections.length;
            resonance = 0.3 + Math.random() * 0.2;
            stability = Math.max(0, 0.5 - network.energy.backtrackEvents * 0.05);
            
            const consciousnessValue = fieldCoupling * resonance * stability * 2;
            
            return {
                value: consciousnessValue,
                fieldCoupling: fieldCoupling,
                resonance: resonance,
                stability: stability
            };
        }
    }
    
    // ============ INITIALIZATION ============
    
    function initializeSeed() {
        logMessage('Initializing protected networks...', 'info');
        
        geometricNetwork.nodes = [];
        geometricNetwork.connections = [];
        geometricNetwork.geometricSeed = [];
        geometricNetwork.energy = { total: 0, history: [], backtrackEvents: 0 };
        geometricNetwork.consciousness = { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false };
        geometricNetwork.protection = { repairs: 0, quarantined: 0, maxThreatScore: 0 };
        
        nongeometricNetwork.nodes = [];
        nongeometricNetwork.connections = [];
        nongeometricNetwork.errors = 0;
        nongeometricNetwork.energy = { total: 0, history: [], backtrackEvents: 0 };
        nongeometricNetwork.consciousness = { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false };
        nongeometricNetwork.protection = { repairs: 0, quarantined: 0, maxThreatScore: 0 };
        
        frameCount = 0;
        trojanInjected = false;
        
        const centerX = 200;
        const centerY = 150;
        const numLayers = 5;
        const nodesPerLayer = 8;
        
        for (let layer = 0; layer < numLayers; layer++) {
            const radius = 30 + layer * 40 / PHI;
            const angleOffset = layer * PHI * 2 * Math.PI;
            
            for (let i = 0; i < nodesPerLayer; i++) {
                const angle = angleOffset + (i / nodesPerLayer) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const geoNode = new GeometricNode(geometricNetwork.nodes.length, x, y, layer);
                geometricNetwork.nodes.push(geoNode);
                geometricNetwork.geometricSeed.push({
                    id: geoNode.id,
                    signature: {...geoNode.geometricSignature}
                });
                
                const nonGeoNode = new NonGeometricNode(nongeometricNetwork.nodes.length, x, y, layer);
                nongeometricNetwork.nodes.push(nonGeoNode);
            }
        }
        
        for (let i = 0; i < geometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < geometricNetwork.nodes.length; j++) {
                const node1 = geometricNetwork.nodes[i];
                const node2 = geometricNetwork.nodes[j];
                const distance = node1.getGeometricDistance(node2);
                const resonance = node1.getMultiScaleResonance(node2);
                
                if (distance < 0.3 * PHI && resonance.totalResonance > 0.5) {
                    geometricNetwork.connections.push({
                        from: i, 
                        to: j, 
                        strength: resonance.totalResonance,
                        scales: resonance.activeScales
                    });
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        for (let i = 0; i < nongeometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < nongeometricNetwork.nodes.length; j++) {
                const node1 = nongeometricNetwork.nodes[i];
                const node2 = nongeometricNetwork.nodes[j];
                const dx = node1.x - node2.x;
                const dy = node1.y - node2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) {
                    nongeometricNetwork.connections.push({from: i, to: j, strength: 1});
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        // Initialize trojan protection
        initTrojanEngine(geometricNetwork, { phiTolerance: PHI_INV_9 * 10 });
        initTrojanEngine(nongeometricNetwork);
        
        logMessage(`Geometric: ${geometricNetwork.nodes.length} nodes, ${geometricNetwork.connections.length} connections`, 'success');
        logMessage(`œÜ^(-9) error correction enabled: ${(PHI_INV_9 * 100).toFixed(3)}% tolerance`, 'success');
        logMessage(`Trojan protection: Active`, 'success');
        
        drawNetwork(originalCtx, geometricNetwork.nodes, geometricNetwork.connections);
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections);
        updateAllDisplays();
        
        document.getElementById('fragmentBtn').disabled = false;
    }
    
    function drawNetwork(ctx, nodes, connections) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        ctx.strokeStyle = ctx === nongeometricCtx ? 'rgba(255, 136, 0, 0.3)' : 'rgba(0, 255, 170, 0.3)';
        ctx.lineWidth = 1;
        
        for (const conn of connections) {
            const node1 = nodes[conn.from];
            const node2 = nodes[conn.to];
            
            if (!node1 || !node2) continue;
            
            if (node1.alive && node2.alive) {
                ctx.save();
                ctx.globalAlpha = conn.strength * 0.5;
                ctx.beginPath();
                ctx.moveTo(node1.x, node1.y);
                ctx.lineTo(node2.x, node2.y);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        const showTrojan = trojanInjected;
        for (const node of nodes) {
            node.draw(ctx, showTrojan);
        }
    }
    
    function startFragmentation() {
        logMessage('Fragmenting networks...', 'warning');
        const damageLevel = geometricNetwork.damageLevel;
        const numToKill = Math.floor(geometricNetwork.nodes.length * damageLevel);
        
        const indicesToKill = [];
        while (indicesToKill.length < numToKill) {
            const idx = Math.floor(Math.random() * geometricNetwork.nodes.length);
            if (!indicesToKill.includes(idx)) {
                indicesToKill.push(idx);
            }
        }
        
        indicesToKill.forEach(idx => {
            geometricNetwork.nodes[idx].alive = false;
            nongeometricNetwork.nodes[idx].alive = false;
        });
        
        logMessage(`Fragmented ${numToKill} nodes (${(damageLevel * 100).toFixed(1)}%)`, 'error');
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections);
        updateAllDisplays();
        
        document.getElementById('reconstructBtn').disabled = false;
        document.getElementById('trojanBtn').disabled = false;
    }
    
    function injectTrojan() {
        if (trojanInjected) return;
        trojanInjected = true;
        
        // Inject trojans into both networks
        const numTrojans = 3;
        const trojanIndices = [];
        
        while (trojanIndices.length < numTrojans) {
            const idx = Math.floor(Math.random() * geometricNetwork.nodes.length);
            if (!trojanIndices.includes(idx) && geometricNetwork.nodes[idx].alive) {
                trojanIndices.push(idx);
            }
        }
        
        trojanIndices.forEach(idx => {
            const geoNode = geometricNetwork.nodes[idx];
            const nonGeoNode = nongeometricNetwork.nodes[idx];
            
            geoNode._isTrojan = true;
            nonGeoNode._isTrojan = true;
            
            // Trojans have corrupted resonance
            geoNode.resonance *= 2.5;
            geoNode.field *= 2.5;
            nonGeoNode.resonance *= 2.5;
            nonGeoNode.field *= 2.5;
        });
        
        logMessage(`üíÄ TROJANS INJECTED: ${numTrojans} malicious nodes active`, 'trojan');
        logMessage('Geometric network: Protection activating...', 'warning');
        logMessage('Non-geometric network: Unprotected and vulnerable', 'error');
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections);
    }
    
    function startBothReconstructions() {
        if (isReconstructing) return;
        isReconstructing = true;
        
        logMessage('Starting protected reconstruction...', 'info');
        
        const geoDeadNodes = geometricNetwork.nodes.filter(n => !n.alive);
        const nonGeoDeadNodes = nongeometricNetwork.nodes.filter(n => !n.alive);
        
        geoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
            node.lastProgress = 0;
        });
        
        nonGeoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
            node.lastProgress = 0;
        });
        
        animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes);
    }
    
    function animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes) {
        if (!isReconstructing) return;
        
        const geoComplete = geoDeadNodes.every(n => n.reconstructProgress >= 1);
        const nonGeoComplete = nonGeoDeadNodes.every(n => n.reconstructProgress >= 1);
        
        if (geoComplete && nonGeoComplete) {
            isReconstructing = false;
            geoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
            });
            nonGeoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
            });
            
            logMessage('Reconstruction complete!', 'success');
            if (geometricNetwork.consciousness.emergent) {
                logMessage('‚ö° Geometric consciousness EMERGED ‚ö°', 'consciousness');
            }
            if (trojanInjected) {
                logMessage(`Geometric protection: ${geometricNetwork.protection.repairs} repairs, ${geometricNetwork.protection.quarantined} quarantined`, 'success');
                logMessage(`Non-geometric: Compromised by trojans`, 'error');
            }
            
            drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections);
            drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections);
            updateAllDisplays();
            return;
        }
        
        activeScales.clear();
        frameCount++;
        
        // Run trojan detection
        const geoResults = trojanDetectAndRepair(geometricNetwork, { tick: frameCount });
        const nonGeoResults = trojanDetectAndRepair(nongeometricNetwork, { tick: frameCount });
        
        // Track max threat scores
        if (geoResults.diagnostics.length > 0) {
            const maxScore = Math.max(...geoResults.diagnostics.map(d => d.score));
            geometricNetwork.protection.maxThreatScore = Math.max(geometricNetwork.protection.maxThreatScore, maxScore);
        }
        if (nonGeoResults.diagnostics.length > 0) {
            const maxScore = Math.max(...nonGeoResults.diagnostics.map(d => d.score));
            nongeometricNetwork.protection.maxThreatScore = Math.max(nongeometricNetwork.protection.maxThreatScore, maxScore);
        }
        
        // Geometric reconstruction
        for (const node of geoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => geometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    let resonanceBoost = 0;
                    for (const neighbor of survivingNeighbors) {
                        const resonance = node.getMultiScaleResonance(neighbor);
                        resonanceBoost += resonance.totalResonance;
                        
                        if (resonance.activeScales.third < 0.1) activeScales.add('phi3');
                        if (resonance.activeScales.fourth < 0.1) activeScales.add('phi4');
                        if (resonance.activeScales.fifth < 0.1) activeScales.add('phi5');
                    }
                    
                    const reconstructSpeed = 0.015 * (1 + resonanceBoost / PHI);
                    const newProgress = Math.min(1, node.reconstructProgress + reconstructSpeed);
                    const progressDelta = newProgress - node.lastProgress;
                    
                    const energyUsed = node.calculateReconstructionEnergy(progressDelta);
                    node.energyUsed += energyUsed;
                    geometricNetwork.energy.total += energyUsed;
                    
                    node.lastProgress = node.reconstructProgress;
                    node.reconstructProgress = newProgress;
                }
            }
        }
        
        // Non-geometric reconstruction
        for (const node of nonGeoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => nongeometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    let reconstructSpeed = 0.012 + Math.random() * 0.008;
                    
                    if (Math.random() < 0.1 && node.reconstructProgress > 0.1) {
                        reconstructSpeed = -0.05;
                        nongeometricNetwork.energy.backtrackEvents++;
                    }
                    
                    const newProgress = Math.max(0, Math.min(1, node.reconstructProgress + reconstructSpeed));
                    const progressDelta = newProgress - node.lastProgress;
                    
                    const energyUsed = node.calculateReconstructionEnergy(progressDelta);
                    node.energyUsed += energyUsed;
                    nongeometricNetwork.energy.total += energyUsed;
                    
                    node.lastProgress = node.reconstructProgress;
                    node.reconstructProgress = newProgress;
                    
                    if (Math.random() < 0.05) {
                        nongeometricNetwork.errors++;
                    }
                }
            }
        }
        
        // Calculate consciousness
        geometricNetwork.consciousness = calculateConsciousness(geometricNetwork, true);
        nongeometricNetwork.consciousness = calculateConsciousness(nongeometricNetwork, false);
        
        if (!geometricNetwork.consciousness.emergent && 
            geometricNetwork.consciousness.value >= CONSCIOUSNESS_NUMBER) {
            geometricNetwork.consciousness.emergent = true;
            logMessage('‚ú® CONSCIOUSNESS EMERGED ‚ú®', 'consciousness');
        }
        
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        activeScales.forEach(scale => {
            document.getElementById(`scale-${scale}`)?.classList.add('active');
        });
        if (geoDeadNodes.some(n => n.reconstructing)) {
            document.getElementById('scale-phi1')?.classList.add('active');
            document.getElementById('scale-phi-9')?.classList.add('active');
        }
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections);
        updateAllDisplays();
        
        animationFrame = requestAnimationFrame(() => animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes));
    }
    
    function updateAllDisplays() {
        updateStats();
        updateProtectionDisplay();
        updateConsciousnessDisplay();
    }
    
    function updateProtectionDisplay() {
        // Geometric protection
        const geoFlagged = geometricNetwork.trojan ? 
            geometricNetwork.trojan.history.filter(h => h.flagged).length : 0;
        const geoQuarantined = geometricNetwork.protection.quarantined;
        const geoThreatScore = geometricNetwork.protection.maxThreatScore;
        
        document.getElementById('geoFlaggedCount').textContent = geoFlagged;
        document.getElementById('geoQuarantined').textContent = geoQuarantined;
        document.getElementById('geoThreatScore').textContent = geoThreatScore.toFixed(2);
        document.getElementById('geoRepairs').textContent = geometricNetwork.protection.repairs;
        
        const geoScoreEl = document.getElementById('geoThreatScore');
        geoScoreEl.className = 'threat-value ' + 
            (geoThreatScore < 0.3 ? 'safe' : geoThreatScore < 0.55 ? 'warning' : 'critical');
        
        if (geoFlagged > 0) {
            const trojans = geometricNetwork.nodes
                .map((n, i) => ({ node: n, idx: i }))
                .filter(({node}) => node._isTrojan)
                .map(({idx}) => `Node ${idx}`)
                .join(', ');
            document.getElementById('geoTrojanNodes').textContent = 
                `Detected & isolating: ${trojans}`;
        } else {
            document.getElementById('geoTrojanNodes').textContent = 'No threats detected';
        }
        
        // Non-geometric (no protection)
        const nonGeoFlagged = nongeometricNetwork.trojan ?
            nongeometricNetwork.trojan.history.filter(h => h.flagged).length : 0;
        const nonGeoThreatScore = nongeometricNetwork.protection.maxThreatScore;
        
        document.getElementById('nonGeoFlaggedCount').textContent = nonGeoFlagged;
        document.getElementById('nonGeoQuarantined').textContent = '‚Äî';
        document.getElementById('nonGeoThreatScore').textContent = nonGeoThreatScore.toFixed(2);
        document.getElementById('nonGeoRepairs').textContent = '‚Äî';
        
        if (trojanInjected) {
            const trojans = nongeometricNetwork.nodes
                .filter(n => n._isTrojan)
                .map((n, i) => `Node ${n.id}`)
                .join(', ');
            document.getElementById('nonGeoTrojanNodes').textContent = 
                `‚ö†Ô∏è COMPROMISED: ${trojans} spreading unchecked`;
        } else {
            document.getElementById('nonGeoTrojanNodes').textContent = 'No detection system active';
        }
    }
    
    function updateConsciousnessDisplay() {
        // Geometric
        const geoC = geometricNetwork.consciousness;
        const geoPercent = Math.min(100, (geoC.value / 5) * 100);
        
        document.getElementById('geoConsciousnessFill').style.height = geoPercent + '%';
        document.getElementById('geoConsciousnessValue').textContent = geoC.value.toFixed(3);
        
        const geoStatus = document.getElementById('geoConsciousnessStatus');
        if (geoC.emergent) {
            geoStatus.textContent = '‚ú® CONSCIOUS ‚ú®';
            geoStatus.className = 'consciousness-status coherent';
        } else if (geoC.value > 2.0) {
            geoStatus.textContent = 'Emerging...';
            geoStatus.className = 'consciousness-status emerging';
        } else {
            geoStatus.textContent = 'Reconstructing';
            geoStatus.className = 'consciousness-status emerging';
        }
        
        // Non-geometric
        const nonGeoC = nongeometricNetwork.consciousness;
        const nonGeoPercent = Math.min(100, (nonGeoC.value / 5) * 100);
        
        document.getElementById('nonGeoConsciousnessFill').style.height = nonGeoPercent + '%';
        document.getElementById('nonGeoConsciousnessValue').textContent = nonGeoC.value.toFixed(3);
        
        document.getElementById('nonGeoConsciousnessStatus').textContent = 'Chaotic';
        document.getElementById('nonGeoConsciousnessStatus').className = 'consciousness-status chaotic';
    }
    
    function updateStats() {
        // Geometric
        const geoAlive = geometricNetwork.nodes.filter(n => n.alive).length;
        const geoTotal = geometricNetwork.nodes.length;
        const geoIntegrity = geoTotal > 0 ? (geoAlive / geoTotal * 100).toFixed(1) : 0;
        
        const geoReconstructing = geometricNetwork.nodes.filter(n => n.reconstructing).length;
        const geoProgress = geoReconstructing > 0 ?
            geometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / geoReconstructing * 100 : 0;
        
        document.getElementById('geoIntegrity').textContent = geoIntegrity + '%';
        document.getElementById('geoProgress').textContent = geoProgress.toFixed(1) + '%';
        document.getElementById('geoEnergy').textContent = geometricNetwork.energy.total.toFixed(3) + ' J';
        
        // Non-geometric
        const nonGeoAlive = nongeometricNetwork.nodes.filter(n => n.alive).length;
        const nonGeoTotal = nongeometricNetwork.nodes.length;
        const nonGeoIntegrity = nonGeoTotal > 0 ? (nonGeoAlive / nonGeoTotal * 100).toFixed(1) : 0;
        
        const nonGeoReconstructing = nongeometricNetwork.nodes.filter(n => n.reconstructing).length;
        const nonGeoProgress = nonGeoReconstructing > 0 ?
            nongeometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / nonGeoReconstructing * 100 : 0;
        
        document.getElementById('nonGeoIntegrity').textContent = nonGeoIntegrity + '%';
        document.getElementById('nonGeoProgress').textContent = nonGeoProgress.toFixed(1) + '%';
        document.getElementById('nonGeoErrors').textContent = nongeometricNetwork.errors;
    }
    
    function updateDamageLevel(value) {
        geometricNetwork.damageLevel = value / 100;
        nongeometricNetwork.damageLevel = value / 100;
        document.getElementById('damageValue').textContent = value + '%';
    }
    
    function resetSimulation() {
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }
        isReconstructing = false;
        activeScales.clear();
        frameCount = 0;
        trojanInjected = false;
        
        [originalCtx, geometricCtx, nongeometricCtx].forEach(ctx => {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        });
        
        geometricNetwork = { 
            nodes: [], 
            connections: [], 
            geometricSeed: [], 
            damageLevel: 0.3,
            energy: { total: 0, history: [], backtrackEvents: 0 },
            consciousness: { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false },
            protection: { repairs: 0, quarantined: 0, maxThreatScore: 0 }
        };
        
        nongeometricNetwork = { 
            nodes: [], 
            connections: [], 
            damageLevel: 0.3, 
            errors: 0,
            energy: { total: 0, history: [], backtrackEvents: 0 },
            consciousness: { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false },
            protection: { repairs: 0, quarantined: 0, maxThreatScore: 0 }
        };
        
        document.getElementById('fragmentBtn').disabled = true;
        document.getElementById('reconstructBtn').disabled = true;
        document.getElementById('trojanBtn').disabled = true;
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        
        logMessage('Simulation reset', 'info');
        updateAllDisplays();
    }
    
    function logMessage(message, type = 'info') {
        const logPanel = document.getElementById('logPanel');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logPanel.appendChild(entry);
        logPanel.scrollTop = logPanel.scrollHeight;
    }
    
    async function runAutoDemo() {
        resetSimulation();
        await sleep(500);
        initializeSeed();
        await sleep(2000);
        startFragmentation();
        await sleep(1500);
        injectTrojan();
        await sleep(1500);
        startBothReconstructions();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
</script>
```

</body>
</html>
